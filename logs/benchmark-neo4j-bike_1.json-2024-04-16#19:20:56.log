--------

--------------------------1-----------------
schema:['date']
---------------------------Execute SQL Query:SELECT date FROM weather WHERE max_temperature_f  >  85-----------------
knowledge: group by type;

can be expressed in Cypher as



match (m:Movie)

return m.type,

       count(*) as movie_count,

       min(m.votes) as min_votes,

       max(m.votes) as max_votes,

       sum(m.votes) as sum_of_votes,

       avg(m.votes) as averge_votes;

The query returns:



+-------------------------------------------------------------------------------------+

| m.type    | movie_count | min_votes | max_votes | sum_of_votes | averge_votes       |

+-------------------------------------------------------------------------------------+

| "movie"   | 947         | 50210     | 2093718   | 242717815    | 256301.8109820486  |

| "tvMovie" | 289         | 1011      | 31496     | 1131873      | 3916.5155709342557 |

+-------------------------------------------------------------------------------------+



2 rows available after 89 ms, consumed after another 0 ms

Relationships and properties

We can also extract information about the relationships in the database:



match (m)-[r]->(n)

return labels(m), type(r), labels(n), count(*) as total

order by total desc;

The pattern (m)-[r]->(n) matches two nodes (m and n) and a relationship (r) from m to n (all relationships in Neo4j have a direction). You can read it like an arrow m --> n where the relationship r is enclosed in square brackets. The function type(r) returns the type of the relationship r. The query returns:



+---------------------------------------------+

examples: Example 1:
SQL: SQL: SELECT city ,  max(lat) FROM station GROUP BY city
target query: Neo4j: MATCH (s:Station) WITH s.city AS city, MAX(s.lat) AS max_lat RETURN city, max_lat
Example 2:
SQL: SQL: SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  94103)
target query: Neo4j: MATCH (t:Trip), (avgTrip:Trip) WHERE t.zip_code = 94103 WITH AVG(avgTrip.duration) AS avgDuration MATCH (t:Trip) WHERE t.duration >= avgDuration RETURN t.id AS id
Example 3:
SQL: SQL: SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1
target query: Neo4j: MATCH (t:Trip) WHERE t.zip_code = 94002 WITH t.bike_id AS bike_id, COUNT(*) AS count ORDER BY count DESC LIMIT 1 RETURN bike_id

Error parsing XML of prompt: not well-formed (invalid token): line 12, column 88
---------------------------Execute Target Query:MATCH (w:Weather) WHERE w.max_temperature_f > 85 RETURN w.date as date-----------------
MATCH (w:Weather) WHERE w.max_temperature_f > 85 RETURN w.date as date
translate SELECT date FROM weather WHERE max_temperature_f  >  85 success

--------------------------2-----------------
schema:['name']
---------------------------Execute SQL Query:SELECT name FROM station WHERE lat  <  37.5-----------------
knowledge: This technique of trying different values (2, 4, 6, ...) until we get a result is rather tedious. Instead we can use -[:ACTED_IN*]- together with Neo4j's function allshortestpaths to get the same result:



match path=allshortestpaths((m:Person {name : 'Jennifer Lawrence'} )

                            -[:ACTED_IN*]-

                            (n:Person {name : 'Daniel Radcliffe'}))

return path;

The following query returns bacon_number, total for each bacon number associated with people in our database and the total with that bacon number.



match path=allshortestpaths(

          (m:Person {name : "Kevin Bacon"} ) -[:ACTED_IN*]- (n:Person))

     where n.person_id <> m.person_id

     return length(path)/2 as bacon_number,

            count(distinct n.person_id) as total

order by bacon_number;

The output:



+----------------------+

| bacon_number | total |

+----------------------+

| 1            | 12    |

| 2            | 99    |

| 3            | 533   |

| 4            | 823   |

| 5            | 292   |

| 6            | 84    |

| 7            | 23    |

+----------------------+



7 rows available after 314 ms, consumed after another 0 ms

examples: Example 1:
SQL: SQL: SELECT city ,  max(lat) FROM station GROUP BY city
target query: Neo4j: MATCH (s:Station) WITH s.city AS city, MAX(s.lat) AS max_lat RETURN city, max_lat
Example 2:
SQL: SQL: SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id
target query: Neo4j: MATCH (s:Station), (t:Trip) WHERE s.id = t.end_station_id WITH s.name AS name, s.lat AS lat, MIN(t.duration) AS min_duration RETURN name, lat, min_duration
Example 3:
SQL: SQL: SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  94103)
target query: Neo4j: MATCH (t:Trip), (avgTrip:Trip) WHERE t.zip_code = 94103 WITH AVG(avgTrip.duration) AS avgDuration MATCH (t:Trip) WHERE t.duration >= avgDuration RETURN t.id AS id

Error parsing XML of prompt: not well-formed (invalid token): line 12, column 88
---------------------------Execute Target Query:MATCH (s:Station) WHERE s.lat < 37.5 RETURN s.name AS name-----------------
MATCH (s:Station) WHERE s.lat < 37.5 RETURN s.name AS name
translate SELECT name FROM station WHERE lat  <  37.5 success
